# toml-pretty-deser Examples

Auto-generated by `dev/collect_examples.py`. Do not edit manually.

To run any example, clone the repo and e.g. `cargo run -p toml-pretty-deser --example e14_improve_errors`

---

## `e01_basic`

# Example 01: Basic struct with no custom validation

Demonstrates the simplest usage of `toml-pretty-deser`: a root struct with
primitive fields (String, i64, bool, f64) and `no_verify` to skip custom validation.

**Run:** `cargo run -p toml-pretty-deser --example e01_basic`

<details>
<summary>Source code</summary>

```rust
//! # Example 01: Basic struct with no custom validation
//!
//! Demonstrates the simplest usage of `toml-pretty-deser`: a root struct with
//! primitive fields (String, i64, bool, f64) and `no_verify` to skip custom validation.

use toml_pretty_deser::prelude::*;

#[tpd(root, no_verify)]
#[derive(Debug)]
struct ServerConfig {
    host: String,
    port: i64,
    debug: bool,
    timeout: f64,
}

fn main() {
    let toml_str = r#"
host = "localhost"
port = 8080
debug = true
timeout = 30.5
"#;

    match ServerConfig::tpd_from_toml(toml_str, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => {
            println!("Parsed config successfully!");
            println!("  host:    {}", config.host);
            println!("  port:    {}", config.port);
            println!("  debug:   {}", config.debug);
            println!("  timeout: {}", config.timeout);
        }
        Err(e) => {
            eprintln!("{}", e.pretty("config.toml"));
        }
    }
}
```

</details>

---

## `e02_nested`

# Example 02: Nested structs

Shows how to nest one struct inside another using `#[tpd(nested)]`.
The inner struct also uses `#[tpd]` (or `#[tpd(no_verify)]`), and the
outer struct uses `#[tpd(root)]`.

**Run:** `cargo run -p toml-pretty-deser --example e02_nested`

<details>
<summary>Source code</summary>

```rust
//! # Example 02: Nested structs
//!
//! Shows how to nest one struct inside another using `#[tpd(nested)]`.
//! The inner struct also uses `#[tpd]` (or `#[tpd(no_verify)]`), and the
//! outer struct uses `#[tpd(root)]`.

use toml_pretty_deser::prelude::*;

#[tpd(no_verify)]
#[derive(Debug)]
struct DatabaseConfig {
    host: String,
    port: u16,
    name: String,
}

#[tpd(root, no_verify)]
#[derive(Debug)]
struct AppConfig {
    app_name: String,
    #[tpd(nested)]
    database: DatabaseConfig,
}

fn main() {
    let toml_str = r#"
app_name = "my-service"

[database]
host = "db.example.com"
port = 5432
name = "mydb"
"#;

    match AppConfig::tpd_from_toml(toml_str, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => {
            println!("App: {}", config.app_name);
            println!("DB:  {}:{}/{}", config.database.host, config.database.port, config.database.name);
        }
        Err(e) => {
            eprintln!("{}", e.pretty("config.toml"));
        }
    }
}
```

</details>

---

## `e03_enums`

# Example 03: Simple string enums

Demonstrates `#[tpd]` on a unit-variant enum, which deserializes from a
TOML string value matching the variant name.

**Run:** `cargo run -p toml-pretty-deser --example e03_enums`

<details>
<summary>Source code</summary>

```rust
//! # Example 03: Simple string enums
//!
//! Demonstrates `#[tpd]` on a unit-variant enum, which deserializes from a
//! TOML string value matching the variant name.

use toml_pretty_deser::prelude::*;

#[tpd]
#[derive(Debug)]
enum LogLevel {
    Debug,
    Info,
    Warning,
    Error,
}

#[tpd(root, no_verify)]
#[derive(Debug)]
struct Config {
    log_level: LogLevel,
    name: String,
}

fn main() {
    // Happy path
    let toml_str = r#"
log_level = "Info"
name = "my-app"
"#;

    match Config::tpd_from_toml(toml_str, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => println!("Log level: {:?}, name: {}", config.log_level, config.name),
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }

    // Error path: invalid variant
    let bad_toml = r#"
log_level = "Verbose"
name = "my-app"
"#;

    println!("\n--- Invalid enum value ---");
    match Config::tpd_from_toml(bad_toml, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(_) => unreachable!(),
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }
}
```

</details>

---

## `e04_tagged_enum`

# Example 04: Tagged enums

Demonstrates `#[tpd(tag = "...")]` for enums whose variants carry struct data.
The tag field in TOML determines which variant to deserialize.

**Run:** `cargo run -p toml-pretty-deser --example e04_tagged_enum`

<details>
<summary>Source code</summary>

```rust
//! # Example 04: Tagged enums
//!
//! Demonstrates `#[tpd(tag = "...")]` for enums whose variants carry struct data.
//! The tag field in TOML determines which variant to deserialize.

use toml_pretty_deser::prelude::*;

#[tpd(no_verify)]
#[derive(Debug)]
struct HttpAction {
    url: String,
    method: String,
}

#[tpd(no_verify)]
#[derive(Debug)]
struct ShellAction {
    command: String,
}

#[tpd(tag = "type")]
#[derive(Debug)]
enum Action {
    Http(HttpAction),
    Shell(ShellAction),
}

#[tpd(root, no_verify)]
#[derive(Debug)]
struct Job {
    name: String,
    #[tpd(nested)]
    action: Action,
}

fn main() {
    let toml_str = r#"
name = "deploy"
[action]
type = "Http"
url = "https://api.example.com/deploy"
method = "POST"
"#;

    match Job::tpd_from_toml(toml_str, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(job) => {
            println!("Job '{}': {:?}", job.name, job.action);
        }
        Err(e) => eprintln!("{}", e.pretty("job.toml")),
    }

    let toml_str2 = r#"
name = "cleanup"
[action]
type = "Shell"
command = "rm -rf /tmp/build"
"#;

    match Job::tpd_from_toml(toml_str2, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(job) => {
            println!("Job '{}': {:?}", job.name, job.action);
            match job.action {
                Action::Http(http) => println!("HTTP action: {} {}", http.method, http.url),
                Action::Shell(shell) => println!("Shell action: {}", shell.command),
            }
        }
        Err(e) => eprintln!("{}", e.pretty("job.toml")),
    }
}
```

</details>

---

## `e05_validation`

# Example 05: Custom verification with VerifyIn

Shows how to implement `VerifyIn<Root>` on the generated `PartialT` struct
to add custom validation logic. Demonstrates:
- `self.field.verify(|v| ...)` for single-field validation
- `TomlValue::new_custom(...)` for multi-span errors

**Run:** `cargo run -p toml-pretty-deser --example e05_validation`

<details>
<summary>Source code</summary>

```rust
//! # Example 05: Custom verification with VerifyIn
//!
//! Shows how to implement `VerifyIn<Root>` on the generated `PartialT` struct
//! to add custom validation logic. Demonstrates:
//! - `self.field.verify(|v| ...)` for single-field validation
//! - `TomlValue::new_custom(...)` for multi-span errors

#![allow(dead_code)]
use toml_pretty_deser::prelude::*;

#[tpd(root)]
#[derive(Debug)]
struct ServerConfig {
    host: String,
    port: u16,
    max_connections: u32,
    min_connections: u32,
}

impl VerifyIn<Root> for PartialServerConfig {
    fn verify(&mut self, _parent: &Root) -> Result<(), ValidationFailure> {
        // Single-field validation: port must be > 1024
        self.port.verify(|p| {
            if *p > 1024 {
                Ok(())
            } else {
                Err(("Port must be greater than 1024".to_string(),
                     Some("Use a port in the range 1025..65535".to_string())))
            }
        });

        // Multi-span error: max_connections must be >= min_connections
        if let Some(max) = self.max_connections.as_ref()
            && let Some(min) = self.min_connections.as_ref()
            && max < min
        {
            let max_val = *max;
            // Create a custom error pointing at both fields
            let spans = vec![
                (self.max_connections.span(), "max_connections is here".to_string()),
                (self.min_connections.span(), "min_connections is here".to_string()),
            ];
            // Store the error on a field — using new_custom on max_connections
            self.max_connections = TomlValue::new_custom(
                Some(max_val),
                spans,
                Some("max_connections must be >= min_connections"),
            );
        }

        Ok(())
    }
}

fn main() {
    // Valid config
    let toml_ok = r#"
host = "localhost"
port = 8080
max_connections = 100
min_connections = 10
"#;

    match ServerConfig::tpd_from_toml(toml_ok, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => println!("Valid config: {:?}", config),
        Err(e) => eprintln!("{}", e.pretty("server.toml")),
    }

    // Invalid: port too low + max < min
    let toml_bad = r#"
host = "localhost"
port = 80
max_connections = 5
min_connections = 50
"#;

    println!("\n--- Validation errors ---");
    match ServerConfig::tpd_from_toml(toml_bad, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(_) => unreachable!(),
        Err(e) => eprintln!("{}", e.pretty("server.toml")),
    }
}
```

</details>

---

## `e06_defaults_and_optionals`

# Example 06: Defaults, optionals, and skip

Demonstrates `#[tpd(default)]`, `Option<T>` fields, `#[tpd(skip)]`,
and manual `.or()` / `.or_with()` / `.or_default()` in a VerifyIn impl.

**Run:** `cargo run -p toml-pretty-deser --example e06_defaults_and_optionals`

<details>
<summary>Source code</summary>

```rust
//! # Example 06: Defaults, optionals, and skip
//!
//! Demonstrates `#[tpd(default)]`, `Option<T>` fields, `#[tpd(skip)]`,
//! and manual `.or()` / `.or_with()` / `.or_default()` in a VerifyIn impl.

use toml_pretty_deser::prelude::*;

#[tpd(root)]
#[derive(Debug)]
struct AppConfig {
    name: String,

    /// Optional field: becomes None if missing from TOML
    description: Option<String>,

    /// Default attribute: uses Default::default() (0 for u32) if missing
    #[tpd(default)]
    retries: u32,

    /// We'll set a manual default via .or_with() in verify
    timeout_ms: u64,

    /// We'll set a manual default via .or() in verify
    log_level: String,

    /// Skipped field: not read from TOML, set programmatically
    #[tpd(skip)]
    computed_id: String,
}

impl VerifyIn<Root> for PartialAppConfig {
    fn verify(&mut self, _parent: &Root) -> Result<(), ValidationFailure> {
        // .or_with(): provide a default via closure if missing
        self.timeout_ms.or_with(|| 5000);

        // .or(): provide a literal default if missing
        self.log_level.or("info".to_string());

        // Skip field: set it directly (it's Option<T> in the partial)
        self.computed_id = Some("auto-generated-id".to_string());

        Ok(())
    }
}

fn main() {
    // Minimal config: most fields use defaults
    let toml_minimal = r#"
name = "my-app"
"#;

    match AppConfig::tpd_from_toml(toml_minimal, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => {
            println!("Minimal config:");
            println!("  name:        {}", config.name);
            println!("  description: {:?}", config.description);
            println!("  retries:     {}", config.retries);
            println!("  timeout_ms:  {}", config.timeout_ms);
            println!("  log_level:   {}", config.log_level);
            println!("  computed_id: {}", config.computed_id);
        }
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }

    // Full config: all fields provided
    let toml_full = r#"
name = "my-app"
description = "A great application"
retries = 3
timeout_ms = 10000
log_level = "debug"
"#;

    println!("\nFull config:");
    match AppConfig::tpd_from_toml(toml_full, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => {
            println!("  name:        {}", config.name);
            println!("  description: {:?}", config.description);
            println!("  retries:     {}", config.retries);
            println!("  timeout_ms:  {}", config.timeout_ms);
            println!("  log_level:   {}", config.log_level);
            println!("  computed_id: {}", config.computed_id);
        }
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }
}
```

</details>

---

## `e07_collections`

# Example 07: Vec and IndexMap collections

Demonstrates `Vec<T>`, `Vec<NestedStruct>`, `IndexMap<String, T>`, and
`IndexMap<String, NestedStruct>`. Shows `[[array_of_tables]]` TOML syntax
for arrays of nested structs.

**Run:** `cargo run -p toml-pretty-deser --example e07_collections`

<details>
<summary>Source code</summary>

```rust
//! # Example 07: Vec and IndexMap collections
//!
//! Demonstrates `Vec<T>`, `Vec<NestedStruct>`, `IndexMap<String, T>`, and
//! `IndexMap<String, NestedStruct>`. Shows `[[array_of_tables]]` TOML syntax
//! for arrays of nested structs.

use indexmap::IndexMap;
use toml_pretty_deser::prelude::*;

#[tpd(no_verify)]
#[derive(Debug)]
struct Endpoint {
    path: String,
    method: String,
}

#[tpd(root, no_verify)]
#[derive(Debug)]
struct ApiConfig {
    /// Simple vec of strings
    allowed_origins: Vec<String>,

    /// Vec of nested structs — uses [[endpoints]] in TOML
    #[tpd(nested)]
    endpoints: Vec<Endpoint>,

    /// IndexMap of simple values — uses [headers] table in TOML
    headers: IndexMap<String, String>,

    /// IndexMap of nested structs — uses [routes.name] tables in TOML
    #[tpd(nested)]
    routes: IndexMap<String, Endpoint>,
}

fn main() {
    let toml_str = r#"
allowed_origins = ["https://example.com", "https://app.example.com"]

[headers]
X-Api-Version = "2.0"
X-Request-Id = "auto"

[[endpoints]]
path = "/health"
method = "GET"

[[endpoints]]
path = "/users"
method = "POST"

[routes.dashboard]
path = "/dashboard"
method = "GET"

[routes.settings]
path = "/settings"
method = "PUT"
"#;

    match ApiConfig::tpd_from_toml(toml_str, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => {
            println!("Origins: {:?}", config.allowed_origins);
            println!("\nEndpoints:");
            for ep in &config.endpoints {
                println!("  {} {}", ep.method, ep.path);
            }
            println!("\nHeaders:");
            for (k, v) in &config.headers {
                println!("  {k}: {v}");
            }
            println!("\nRoutes:");
            for (name, ep) in &config.routes {
                println!("  {name}: {} {}", ep.method, ep.path);
            }
        }
        Err(e) => eprintln!("{}", e.pretty("api.toml")),
    }
}
```

</details>

---

## `e08_aliases_and_casing`

# Example 08: Field aliases, enum variant aliases, and FieldMatchMode

Shows `#[tpd(alias = "...")]` on fields and enum variants,
`FieldMatchMode::AnyCase` for case-insensitive matching, and
`VecMode::SingleOk` to allow single values where arrays are expected.

**Run:** `cargo run -p toml-pretty-deser --example e08_aliases_and_casing`

<details>
<summary>Source code</summary>

```rust
//! # Example 08: Field aliases, enum variant aliases, and FieldMatchMode
//!
//! Shows `#[tpd(alias = "...")]` on fields and enum variants,
//! `FieldMatchMode::AnyCase` for case-insensitive matching, and
//! `VecMode::SingleOk` to allow single values where arrays are expected.


#![allow(dead_code)]
use toml_pretty_deser::prelude::*;

/// Simple enum with variant aliases.
/// "Warn" and "Caution" both map to the Warning variant.
#[tpd]
#[derive(Debug)]
enum Severity {
    Info,
    #[tpd(alias = "Warn", alias = "Caution")]
    Warning,
    Error,
    #[tpd(alias = "Fatal")]
    Critical,
}

#[tpd(root, no_verify)]
#[derive(Debug)]
struct Config {
    /// Accepts "host", "hostname", or "server" in TOML
    #[tpd(alias = "hostname", alias = "server")]
    host: String,

    /// Accepts "port" or "listen_port"
    #[tpd(alias = "listen_port")]
    port: u16,

    /// Vec field: with SingleOk, `tags = "web"` becomes `vec!["web"]`
    tags: Vec<String>,

    /// Enum field with variant aliases
    severity: Severity,
}

fn main() {
    // Using field aliases + canonical enum variant name
    let toml_aliases = r#"
hostname = "example.com"
listen_port = 443
tags = ["web", "production"]
severity = "Warning"
"#;

    println!("--- Field aliases + canonical enum variant ---");
    match Config::tpd_from_toml(toml_aliases, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => println!("{:?}", config),
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }

    // Using enum variant aliases: "Warn" and "Fatal" resolve to Warning and Critical
    let toml_enum_aliases = r#"
host = "example.com"
port = 8080
tags = ["api"]
severity = "Warn"
"#;

    println!("\n--- Enum variant alias 'Warn' -> Warning ---");
    match Config::tpd_from_toml(toml_enum_aliases, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => println!("{:?}", config),
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }

    let toml_fatal = r#"
host = "example.com"
port = 9090
tags = ["monitoring"]
severity = "Fatal"
"#;

    println!("\n--- Enum variant alias 'Fatal' -> Critical ---");
    match Config::tpd_from_toml(toml_fatal, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => println!("{:?}", config),
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }

    // AnyCase mode: field names are case-insensitive
    let toml_anycase = r#"
HOST = "example.com"
Port = 8080
TAGS = ["api"]
SEVERITY = "Caution"
"#;

    println!("\n--- AnyCase mode + enum alias 'Caution' -> Warning ---");
    match Config::tpd_from_toml(toml_anycase, FieldMatchMode::AnyCase, VecMode::Strict) {
        Ok(config) => println!("{:?}", config),
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }

    // SingleOk vec mode: single values auto-wrap into arrays
    let toml_single = r#"
host = "localhost"
port = 3000
tags = "dev"
severity = "Info"
"#;

    println!("\n--- SingleOk vec mode ---");
    match Config::tpd_from_toml(toml_single, FieldMatchMode::Exact, VecMode::SingleOk) {
        Ok(config) => println!("{:?}", config),
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }
}
```

</details>

---

## `e09_adapter_functions`

# Example 09: Adapter functions with `#[tpd(with = "fn")]`

Shows how to use adapter functions that transform values during
deserialization. The adapter function signature is:
`fn(TomlValue<InputType>) -> TomlValue<OutputType>`
(which means that both types must implement `Visitor`

**Run:** `cargo run -p toml-pretty-deser --example e09_adapter_functions`

<details>
<summary>Source code</summary>

```rust
//! # Example 09: Adapter functions with `#[tpd(with = "fn")]`
//!
//! Shows how to use adapter functions that transform values during
//! deserialization. The adapter function signature is:
//! `fn(TomlValue<InputType>) -> TomlValue<OutputType>`
//! (which means that both types must implement `Visitor`

use toml_pretty_deser::prelude::*;

/// Adapter: read a string from TOML and uppercase it.
fn to_uppercase(input: TomlValue<String>) -> TomlValue<String> {
    input.map(|s| s.to_uppercase())
}

/// Adapter: read an integer from TOML and convert it to a String.
fn int_to_string(input: TomlValue<i64>) -> TomlValue<String> {
    input.map(|n| n.to_string())
}

#[tpd(root, no_verify)]
#[derive(Debug)]
struct Config {
    #[tpd(with = "to_uppercase")]
    environment: String,

    #[tpd(with = "int_to_string")]
    version_string: String,

    /// Regular field for comparison
    name: String,
}

fn main() {
    let toml_str = r#"
environment = "production"
version_string = 42
name = "my-service"
"#;

    match Config::tpd_from_toml(toml_str, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => {
            println!("environment:    {} (was 'production', uppercased by adapter)", config.environment);
            println!("version_string: {} (was integer 42, converted to string)", config.version_string);
            println!("name:           {} (no adapter, passed through)", config.name);
        }
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }
}
```

</details>

---

## `e10_custom_types`

# Example 10: Custom types with `impl_visitor!` and `impl_visitor_for_try_from_str!`

Shows how to make custom types work with toml-pretty-deser:
- `impl_visitor_for_from_str!` for types implementing `From<&str>`
- `impl_visitor_for_try_from_str!` for types implementing `TryFrom<&str>`
- `impl_visitor!` for full control over deserialization

**Run:** `cargo run -p toml-pretty-deser --example e10_custom_types`

<details>
<summary>Source code</summary>

```rust
//! # Example 10: Custom types with `impl_visitor!` and `impl_visitor_for_try_from_str!`
//!
//! Shows how to make custom types work with toml-pretty-deser:
//! - `impl_visitor_for_from_str!` for types implementing `From<&str>`
//! - `impl_visitor_for_try_from_str!` for types implementing `TryFrom<&str>`
//! - `impl_visitor!` for full control over deserialization

use toml_pretty_deser::prelude::*;

// --- From<&str> example ---

#[derive(Debug)]
struct Email(String);

impl From<&str> for Email {
    fn from(s: &str) -> Self {
        Email(s.to_string())
    }
}

impl_visitor_for_from_str!(Email);

// --- TryFrom<&str> example ---

#[derive(Debug)]
struct Port(u16);

impl TryFrom<&str> for Port {
    type Error = String;
    fn try_from(s: &str) -> Result<Self, String> {
        let n: u16 = s.parse().map_err(|e| format!("{e}"))?;
        if n > 0 {
            Ok(Port(n))
        } else {
            Err("port must be > 0".to_string())
        }
    }
}

impl_visitor_for_try_from_str!(Port, "Provide a port number as a string, e.g. '8080'");

// --- Full impl_visitor! example ---

#[derive(Debug)]
struct HexColor(u8, u8, u8);

impl_visitor!(HexColor, |helper| {
    match helper.item.as_str() {
        Some(s) if s.starts_with('#') && s.len() == 7 => {
            let r = u8::from_str_radix(&s[1..3], 16);
            let g = u8::from_str_radix(&s[3..5], 16);
            let b = u8::from_str_radix(&s[5..7], 16);
            match (r, g, b) {
                (Ok(r), Ok(g), Ok(b)) => TomlValue::new_ok(HexColor(r, g, b), helper.span()),
                _ => TomlValue::new_validation_failed(
                    helper.span(),
                    "Invalid hex digits".to_string(),
                    Some("Use format '#RRGGBB' with valid hex digits".to_string()),
                ),
            }
        }
        Some(_) => TomlValue::new_validation_failed(
            helper.span(),
            "Invalid color format".to_string(),
            Some("Use format '#RRGGBB', e.g. '#ff0000'".to_string()),
        ),
        None => TomlValue::new_wrong_type(helper.item, helper.span(), "string"),
    }
});

#[tpd(root, no_verify)]
#[derive(Debug)]
struct ThemeConfig {
    admin_email: Email,
    api_port: Port,
    background: HexColor,
}

fn main() {
    let toml_str = r##"
admin_email = "admin@example.com"
api_port = "8080"
background = "#1a2b3c"
"##;

    match ThemeConfig::tpd_from_toml(toml_str, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => {
            println!("Email: {}", config.admin_email.0);
            println!("Port:  {}", config.api_port.0);
            println!("Color: rgb({}, {}, {})", config.background.0, config.background.1, config.background.2);
        }
        Err(e) => eprintln!("{}", e.pretty("theme.toml")),
    }

    // Error case: invalid port and color
    let bad_toml = r##"
admin_email = "test@test.com"
api_port = "not-a-number"
background = "#xyz"
"##;

    println!("\n--- Validation errors ---");
    match ThemeConfig::tpd_from_toml(bad_toml, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(_) => unreachable!(),
        Err(e) => eprintln!("{}", e.pretty("theme.toml")),
    }
}
```

</details>

---

## `e11_absorb_remaining`

# Example 11: Absorb remaining keys with `#[tpd(absorb_remaining)]`

Shows how to capture all unmatched TOML keys into an `IndexMap`,
useful for extension fields or pass-through configuration.

**Run:** `cargo run -p toml-pretty-deser --example e11_absorb_remaining`

<details>
<summary>Source code</summary>

```rust
//! # Example 11: Absorb remaining keys with `#[tpd(absorb_remaining)]`
//!
//! Shows how to capture all unmatched TOML keys into an `IndexMap`,
//! useful for extension fields or pass-through configuration.

use indexmap::IndexMap;
use toml_pretty_deser::prelude::*;

#[tpd(root, no_verify)]
#[derive(Debug)]
struct PluginConfig {
    /// Known field
    name: String,
    /// Known field
    enabled: bool,
    /// All other keys are captured here
    #[tpd(absorb_remaining)]
    settings: IndexMap<String, String>,
}

fn main() {
    let toml_str = r#"
name = "image-resizer"
enabled = true
max_width = "1920"
max_height = "1080"
format = "webp"
quality = "85"
"#;

    match PluginConfig::tpd_from_toml(toml_str, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => {
            println!("Plugin: {} (enabled={})", config.name, config.enabled);
            println!("Extra settings:");
            for (k, v) in &config.settings {
                println!("  {k} = {v}");
            }
        }
        Err(e) => eprintln!("{}", e.pretty("plugin.toml")),
    }
}
```

</details>

---

## `e12_adapt_in_verify`

# Example 12: Two-phase transformation with `adapt_in_verify`

Shows `#[tpd(adapt_in_verify)]` and `#[tpd(adapt_in_verify(Type))]` for
transforming fields during the verification phase. This is useful when a
field's TOML type differs from its final Rust type.

Also demonstrates the nested adapt pattern with `Rc<RefCell<T>>`.

**Run:** `cargo run -p toml-pretty-deser --example e12_adapt_in_verify`

<details>
<summary>Source code</summary>

```rust
//! # Example 12: Two-phase transformation with `adapt_in_verify`
//!
//! Shows `#[tpd(adapt_in_verify)]` and `#[tpd(adapt_in_verify(Type))]` for
//! transforming fields during the verification phase. This is useful when a
//! field's TOML type differs from its final Rust type.
//!
//! Also demonstrates the nested adapt pattern with `Rc<RefCell<T>>`.

use std::cell::RefCell;
use std::rc::Rc;
use toml_pretty_deser::prelude::*;

// --- Leaf adapt_in_verify ---

#[tpd(root)]
#[derive(Debug)]
struct Config {
    /// Deserializes as a toml_edit::Item (the default for bare adapt_in_verify),
    /// then converted to usize (string length) in verify.
    #[tpd(adapt_in_verify)]
    name_length: usize,

    /// Deserializes as String first, then parsed to usize in verify.
    #[tpd(adapt_in_verify(String))]
    count: usize,
}

impl VerifyIn<Root> for PartialConfig {
    fn verify(&mut self, _parent: &Root) -> Result<(), ValidationFailure> {
        // adapt_in_verify (bare): receives toml_edit::Item
        self.name_length.adapt(|item, span| {
            match item.as_str() {
                Some(s) => TomlValue::new_ok(s.len(), span),
                None => TomlValue::new_wrong_type(&item, span, "string"),
            }
        });

        // adapt_in_verify(String): receives String
        self.count.adapt(|s, span| {
            match s.parse::<usize>() {
                Ok(n) => TomlValue::new_ok(n, span),
                Err(_) => TomlValue::new_validation_failed(
                    span,
                    "Not a valid number".to_string(),
                    Some("Provide a numeric string like '42'".to_string()),
                ),
            }
        });

        Ok(())
    }
}

// --- Nested adapt_in_verify with Rc<RefCell<T>> ---

#[tpd(no_verify)]
#[derive(Debug)]
struct InnerData {
    value: u32,
    label: String,
}

#[tpd(root)]
#[derive(Debug)]
struct SharedConfig {
    name: String,
    #[tpd(adapt_in_verify, nested)]
    shared_data: Rc<RefCell<InnerData>>,
}

impl VerifyIn<Root> for PartialSharedConfig {
    fn verify(&mut self, _parent: &Root) -> Result<(), ValidationFailure> {
        // Nested adapt: receives the concrete InnerData (already converted from partial)
        self.shared_data.adapt(|inner, span| {
            TomlValue::new_ok(Rc::new(RefCell::new(inner)), span)
        });
        Ok(())
    }
}

fn main() {
    // Leaf adapt examples
    let toml_str = r#"
name_length = "hello"
count = "42"
"#;

    println!("--- Leaf adapt_in_verify ---");
    match Config::tpd_from_toml(toml_str, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => {
            println!("name_length: {} (length of 'hello')", config.name_length);
            println!("count: {} (parsed from '42')", config.count);
        }
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }

    // Nested adapt example
    let toml_nested = r#"
name = "shared-app"
[shared_data]
value = 100
label = "important"
"#;

    println!("\n--- Nested adapt_in_verify (Rc<RefCell<T>>) ---");
    match SharedConfig::tpd_from_toml(toml_nested, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => {
            let data = config.shared_data.borrow();
            println!("name: {}", config.name);
            println!("shared_data: value={}, label={}", data.value, data.label);
        }
        Err(e) => eprintln!("{}", e.pretty("config.toml")),
    }
}
```

</details>

---

## `e13_error_handling`

# Example 13: Working with DeserError and partial results

Shows how to handle `DeserError::DeserFailure` to access both error messages
and partial results. This is the library's key differentiator: even when
deserialization fails, you get back the partial struct with whatever fields
were successfully parsed.

**Run:** `cargo run -p toml-pretty-deser --example e13_error_handling`

<details>
<summary>Source code</summary>

```rust
//! # Example 13: Working with DeserError and partial results
//!
//! Shows how to handle `DeserError::DeserFailure` to access both error messages
//! and partial results. This is the library's key differentiator: even when
//! deserialization fails, you get back the partial struct with whatever fields
//! were successfully parsed.

#![allow(dead_code)]
use toml_pretty_deser::prelude::*;

#[tpd(root, no_verify)]
#[derive(Debug)]
struct Config {
    name: String,
    port: u16,
    debug: bool,
    workers: u8,
}

fn main() {
    // TOML with multiple errors: port is wrong type, workers overflows u8
    let toml_str = r#"
name = "my-app"
port = "not-a-number"
debug = true
workers = 999
"#;

    match Config::tpd_from_toml(toml_str, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => {
            println!("Config: {:?}", config);
        }
        Err(ref e @ DeserError::DeserFailure(ref errors, ref partial)) => {
            // Pretty-print the errors
            println!("=== Pretty error output ===");
            println!("{}", e.pretty("config.toml"));

            // Access individual errors
            println!("=== {} error(s) found ===", errors.len());
            for (i, err) in errors.iter().enumerate() {
                println!("Error {}: {}", i + 1, err.pretty("config.toml"));
            }

            // Access the partial result: successfully-parsed fields are available!
            println!("=== Partial result ===");
            println!("  name (ok):    {:?}", partial.name.as_ref());
            println!("  port (err):   {:?}", partial.port.as_ref());
            println!("  debug (ok):   {:?}", partial.debug.as_ref());
            println!("  workers (err):{:?}", partial.workers.as_ref());
        }
        Err(DeserError::ParsingFailure(toml_err, _source)) => {
            // TOML syntax error — no partial available
            eprintln!("TOML syntax error: {toml_err}");
        }
    }
}
```

</details>

---

## `e14_improve_errors`

# Example 14: Improving error messages downstream

Shows how to iterate over partial results in `VerifyIn` and amend the help
text on errors — for example, adding links to per-plugin documentation.

The key idea: inside `VerifyIn::verify` you have mutable access to every
`TomlValue` field. Since `TomlValue.state` is public, you can match on
error variants and enrich their help text before the errors are collected.

**Run:** `cargo run -p toml-pretty-deser --example e14_improve_errors`

<details>
<summary>Source code</summary>

```rust
//! # Example 14: Improving error messages downstream
//!
//! Shows how to iterate over partial results in `VerifyIn` and amend the help
//! text on errors — for example, adding links to per-plugin documentation.
//!
//! The key idea: inside `VerifyIn::verify` you have mutable access to every
//! `TomlValue` field. Since `TomlValue.state` is public, you can match on
//! error variants and enrich their help text before the errors are collected.


#![allow(dead_code)]
use toml_pretty_deser::prelude::*;

#[tpd(no_verify)]
#[derive(Debug)]
struct Plugin {
    name: String,
    version: u32,
    enabled: bool,
}

#[tpd(root)]
#[derive(Debug)]
struct Config {
    #[tpd(nested)]
    plugins: Vec<Plugin>,
}

impl VerifyIn<Root> for PartialConfig {
    fn verify(&mut self, _parent: &Root) -> Result<(), ValidationFailure> {
        // Iterate through all plugins in the partial vec and amend errors
        if let Some(plugins_vec) = &mut self.plugins.value {
            for (i, plugin_tv) in plugins_vec.iter_mut().enumerate() {
                if let Some(plugin) = &mut plugin_tv.value {
                    // Build a doc link specific to this plugin's index/name
                    let plugin_name = plugin.name.as_ref().map_or("unknown", |s| s.as_str());
                    let doc_link = format!(
                        "See https://docs.example.com/plugins/{plugin_name} for the schema"
                    );

                    amend_help(&mut plugin.name, &doc_link);
                    amend_help(&mut plugin.version, &doc_link);
                    amend_help(&mut plugin.enabled, &doc_link);
                }

                // Also handle the case where the plugin table itself had
                // unknown keys (the error lives on plugin_tv, not the inner fields)
                if let TomlValueState::UnknownKeys(keys) = &mut plugin_tv.state {
                    let doc_link = format!(
                        "See https://docs.example.com/plugins for allowed keys (plugin #{})", i
                    );
                    for key in keys {
                        key.help = format!("{}\n{doc_link}", key.help);
                    }
                }
            }
        }
        Ok(())
    }
}

/// Append a documentation link to the help text of a single TomlValue,
/// if it is in an error state that carries help text.
fn amend_help<T>(field: &mut TomlValue<T>, extra: &str) {
    match &mut field.state {
        TomlValueState::WrongType { span, expected, found } => {
            // WrongType has no help field — replace with ValidationFailed
            // so we can attach our documentation link.
            field.state = TomlValueState::ValidationFailed {
                span: span.clone(),
                message: format!("Expected {expected}, found {found}"),
                help: Some(extra.to_string()),
            };
        }
        TomlValueState::ValidationFailed { help, .. } => {
            let combined = match help.take() {
                Some(existing) => format!("{existing}\n{extra}"),
                None => extra.to_string(),
            };
            *help = Some(combined);
        }
        TomlValueState::Missing { .. } => {
            // Missing has no help field — replace with Custom to attach help.
            let parent_span = field.span();
            field.state = TomlValueState::Custom {
                spans: vec![(parent_span, "Required field is missing".to_string())],
                help: Some(extra.to_string()),
            };
        }
        // Ok, Nested, NotSet, etc. — nothing to amend
        _ => {}
    }
}

fn main() {
    // TOML with several errors across plugins:
    // - plugin 0: "version" has wrong type (string instead of integer)
    // - plugin 1: "enabled" is missing
    // - plugin 2: has an unknown key "colour"
    let toml_str = r#"
[[plugins]]
name = "image-resize"
version = "latest"
enabled = true

[[plugins]]
name = "cache-buster"
version = 2

[[plugins]]
name = "theme-engine"
version = 1
enabled = false
colour = "blue"
"#;

    match Config::tpd_from_toml(toml_str, FieldMatchMode::Exact, VecMode::Strict) {
        Ok(config) => println!("All good: {:?}", config),
        Err(e) => {
            println!("Errors with amended help text:\n");
            println!("{}", e.pretty("plugins.toml"));
        }
    }
    panic!();
}
```

</details>

---

