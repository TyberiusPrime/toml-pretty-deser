--- toml-pretty-deser/src/lib.rs
+++ replace deserialize_with_mode -> Result<T, DeserError<P>> with Ok(Default::default())
@@ -418,43 +418,17 @@
 {
     deserialize_with_mode(source, FieldMatchMode::default())
 }
 
 pub fn deserialize_with_mode<P, T>(source: &str, mode: FieldMatchMode) -> Result<T, DeserError<P>>
 where
     P: FromTomlTable<()> + VerifyFromToml<()> + ToConcrete<T>,
 {
-    let parsed_toml = source.parse::<Document<String>>()?;
-    let source = Rc::new(RefCell::new(source.to_string()));
-
-    let errors = Rc::new(RefCell::new(Vec::new()));
-    let mut helper = TomlHelper::new(parsed_toml.as_table(), errors.clone(), mode);
-
-    let partial = P::from_toml_table(&mut helper, &()).verify(&mut helper, &());
-    helper.deny_unknown();
-
-    partial.collect_errors(&errors);
-    if !errors.borrow().is_empty() {
-        return Err(DeserError::DeserFailure(
-            helper.into_inner(&source),
-            partial,
-        ));
-    }
-
-    if partial.can_concrete() {
-        Ok(partial
-            .to_concrete()
-            .expect("can_concrete() returned true; qed"))
-    } else {
-        Err(DeserError::StillIncomplete(
-            helper.into_inner(&source),
-            partial,
-        ))
-    }
+    Ok(Default::default()) /* ~ changed by cargo-mutants ~ */
 }
 
 fn suggest_alternatives<T: AsRef<str>>(current: &str, available: &[T]) -> String {
     if current.is_empty() {
         let mut sorted: Vec<&str> = available.iter().map(AsRef::as_ref).collect::<Vec<&str>>();
         sorted.sort_unstable();
         return format!("Available are: {}", format_quoted_list(&sorted));
     }
