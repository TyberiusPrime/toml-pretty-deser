--- toml-pretty-deser/src/lib.rs
+++ replace HydratedAnnotatedError::pretty -> String with String::new()
@@ -609,128 +609,17 @@
             span,
             msg: msg.to_string(),
         });
     }
 }
 
 impl HydratedAnnotatedError {
     pub fn pretty(&self, source_name: &str) -> String {
-        use bstr::{BStr, ByteSlice};
-        use codesnake::{Block, CodeWidth, Label, LineIndex};
-        use std::fmt::Write;
-
-        let source = self.source.borrow();
-
-        if !self.inner.spans.is_empty() {
-            let idx = LineIndex::new(&source);
-            let mut spans = self.inner.spans.clone();
-            spans.sort_by_key(|span| span.span.start);
-
-            let mut previous_newline =
-                memchr::memmem::rfind(&source.as_bytes()[..spans[0].span.start], b"\n");
-            let this_line_is_block_start = source.as_bytes()[previous_newline.unwrap_or(0)..]
-                .trim_ascii_start()
-                .starts_with(b"[");
-            if this_line_is_block_start {
-                previous_newline = None;
-            }
-
-            let mut labels = Vec::new();
-
-            for span in spans.into_iter() {
-                labels.push(Label::new(span.span).with_text(span.msg));
-            }
-
-            let block = Block::new(&idx, labels).unwrap_or_else(|| {
-                let mut spans = self.inner.spans.clone();
-                spans.sort_by_key(|span| span.span.start);
-                let span_str: Vec<_> = spans
-                    .iter()
-                    .map(|span| format!("{}..{}: {}", span.span.start, span.span.end, span.msg))
-                    .collect();
-                let span_str = span_str.join("\n");
-                let final_message = format!(
-                    "Error spans were overlapping so we were unable to process a pretty code block. Spans & messages:\n{}",
-                    span_str
-                );
-                let labels = vec![Label::new(0..0).with_text(final_message)];
-                Block::new(&idx, labels).expect("can not fail")
-            });
-
-            let (lines_before, digits_needed) = match previous_newline {
-                None => ("".to_string(), 1),
-                Some(previous_newline) => {
-                    let upto_span = &BStr::new(source.as_bytes())[..previous_newline];
-                    let lines: Vec<_> = upto_span.lines().collect();
-                    let str_line_no = format!("{}", lines.len());
-                    let digits_needed = str_line_no.len();
-                    let mut seen_opening = false;
-                    let mut lines_before: Vec<_> = lines
-                        .into_iter()
-                        .enumerate()
-                        .map(|(line_no, line)| (line_no, line))
-                        .rev()
-                        .take_while(move |x| {
-                            if BStr::new(x.1).trim_ascii_start().starts_with(b"[") {
-                                seen_opening = true;
-                                true
-                            } else {
-                                !seen_opening
-                            }
-                        })
-                        .map(|(line_no, line)| {
-                            format!(
-                                "{:>digits_needed$} │ {}",
-                                line_no + 1,
-                                std::string::String::from_utf8_lossy(line)
-                            )
-                        })
-                        .collect();
-                    lines_before.reverse();
-                    (lines_before.join("\n"), digits_needed)
-                }
-            };
-
-            let block = block.map_code(|c| CodeWidth::new(c, c.len()));
-            let mut out = String::new();
-            writeln!(&mut out, "{}{}", block.prologue(), source_name).expect("can't fail");
-            write!(&mut out, " {:digits_needed$}┆\n{}\n", " ", lines_before).expect("can't fail");
-            let blockf: String = format!("{}", block)
-                .lines()
-                .skip(1)
-                .map(|x| format!("{}\n", x))
-                .collect();
-            write!(&mut out, "{}", blockf).expect("can't fail");
-            writeln!(&mut out, "{}", block.epilogue()).expect("can't fail");
-
-            if let Some(help) = self.inner.help.as_ref() {
-                if !help.is_empty() {
-                    let mut first = true;
-                    write!(&mut out, "Hint: ").expect("Can't fail");
-                    for line in help.lines() {
-                        if !first {
-                            write!(&mut out, "      ").expect("can't fail");
-                        }
-                        first = false;
-                        writeln!(&mut out, "{}", line).expect("can't fail");
-                    }
-                }
-            }
-            out
-        } else {
-            format!(
-                "ConfigError at unknown location. Help text: {}",
-                self.inner
-                    .help
-                    .as_ref()
-                    .map(|x| x.as_str())
-                    .unwrap_or("None available")
-            )
-        }
+        String::new() /* ~ changed by cargo-mutants ~ */
     }
 }
 
 /// Stores information about expected fields and their aliases
 #[derive(Debug, Clone)]
 pub struct FieldInfo {
     pub name: String,
     pub aliases: Vec<&'static str>,
