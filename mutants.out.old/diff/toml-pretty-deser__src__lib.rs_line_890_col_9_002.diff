--- toml-pretty-deser/src/lib.rs
+++ replace TomlHelper<'a>::get_with_aliases -> TomlValue<T> with TomlValue::new()
@@ -882,75 +882,17 @@
         self.get_with_aliases(key, vec![])
     }
 
     pub fn get_with_aliases<T>(&mut self, query_key: &str, aliases: Vec<&'static str>) -> TomlValue<T>
     where
         TomlValue<T>: FromTomlItem,
         T:std::fmt::Debug,
     {
-        let parent_span = if let Some(table) = self.table {
-            table.span().unwrap_or(0..0)
-        } else if let Some(inline_table) = self.inline_table {
-            inline_table.span().unwrap_or(0..0)
-        } else {
-            0..0
-        };
-
-        // Register this field as expected
-        self.expect_field(query_key, &aliases);
-
-        // Try to find a matching key (considering aliases and match mode)
-        let found_keys = self.find_matching_keys(query_key, &aliases);
-
-        match found_keys.len() {
-            0 => {
-                // No match found
-                let mut res: TomlValue<T> = //todo: refactor into new_empty_missing...
-                    FromTomlItem::from_toml_item(&toml_edit::Item::None, parent_span.clone());
-                if let TomlValueState::Missing { ref mut key, .. } = res.state {
-                    if key.is_empty() {
-                        *key = query_key.to_string().clone();
-                    }
-                }
-                res
-            }
-            1 => {
-                let (matched_key, item) = found_keys.iter().next().unwrap();
-                let res: TomlValue<T> = FromTomlItem::from_toml_item(&item, parent_span);
-                self.observed.push(self.match_mode.normalize(&matched_key));
-                res
-            }
-            _ => {
-                let spans = found_keys
-                    .iter()
-                    .map(|(_matched_key, item)| item.span().unwrap_or(0..0))
-                    .collect();
-
-                let mut res: TomlValue<T> =
-                    FromTomlItem::from_toml_item(&toml_edit::Item::None, parent_span);
-                res.state = TomlValueState::MultiDefined {
-                    key: query_key.to_string(),
-                    spans,
-                };
-                res
-                // let res = TomlValue<T> =
-                // let iter = found_keys.iter();
-                // let first = iter.next().unwrap();
-                // let first_span = first[1].span().unwrap_or(0..0);
-                // let mut err = AnnotatedError::placed(
-                //     first_span,
-                //     &format!("Key/alias conflict with key."),
-                //     "Use only one of the keys involved",
-                // );
-                // for (_matched_key, item) in iter {
-                //     err.add_span(item.span().unwrap_or(0..0), "Also defined here");
-                // }
-            }
-        }
+        TomlValue::new() /* ~ changed by cargo-mutants ~ */
     }
 
     pub fn add_err(&self, err: AnnotatedError) {
         self.errors.borrow_mut().push(err);
     }
 
     fn span_from_key(&self, key: &str) -> Range<usize> {
         if let Some(table) = self.table {
