
*** toml-pretty-deser-macros/src/lib.rs:187:5: replace make_partial -> TokenStream with Default::default()

*** mutation diff:
--- toml-pretty-deser-macros/src/lib.rs
+++ replace make_partial -> TokenStream with Default::default()
@@ -179,301 +179,10 @@
         }
         _ => false,
     }
 }
 
 #[proc_macro_attribute]
 pub fn make_partial(attr: TokenStream, item: TokenStream) -> TokenStream {
     // Parse the boolean argument (default to true)
-    let generate_verify = if attr.is_empty() {
-        true
-    } else {
-        let attr_str = attr.to_string();
-        match attr_str.as_str() {
-            "true" => true,
-            "false" => false,
-            _ => panic!("make_partial expects 'true' or 'false', got: {}", attr_str),
-        }
-    };
-
-    let input = parse_macro_input!(item as DeriveInput);
-
-    let struct_name = &input.ident;
-    let partial_name = format_ident!("Partial{}", struct_name);
-    let generics = &input.generics;
-    let (impl_generics, ty_generics, where_clause) = generics.split_for_impl();
-
-    let fields = match &input.data {
-        Data::Struct(data) => match &data.fields {
-            Fields::Named(fields) => &fields.named,
-            _ => panic!("make_partial only supports structs with named fields"),
-        },
-        _ => panic!("make_partial only supports structs"),
-    };
-
-    // Create a version of the input struct with #[nested], #[as_enum], and #[alias(...)] attributes stripped
-    let mut cleaned_input = input.clone();
-    if let Data::Struct(ref mut data) = cleaned_input.data {
-        if let Fields::Named(ref mut fields) = data.fields {
-            for field in fields.named.iter_mut() {
-                field.attrs.retain(|attr| {
-                    !attr.path().is_ident("nested")
-                        && !attr.path().is_ident("as_enum")
-                        && !attr.path().is_ident("alias")
-                });
-            }
-        }
-    }
-
-    // Validate nested fields first
-    for f in fields.iter() {
-        if is_nested_field(f) {
-            let ty = &f.ty;
-            if is_option_type(ty) {
-                if extract_option_inner_type(ty).is_none() {
-                    panic!("nested attribute on Option field requires a simple inner type name");
-                }
-            } else if is_vec_type(ty) {
-                if extract_vec_inner_type(ty).is_none() {
-                    panic!("nested attribute on Vec field requires a simple inner type name");
-                }
-            } else if extract_type_name(ty).is_none() {
-                panic!("nested attribute requires a simple type name");
-            }
-        }
-    }
-
-    let partial_fields: Vec<_> = fields
-        .iter()
-        .map(|f| {
-            let name = &f.ident;
-            let ty = &f.ty;
-
-            if is_nested_field(f) {
-                // Check if this is Option<InnerType>, Vec<InnerType>, or just InnerType
-                if is_option_type(ty) {
-                    // For Option<Nested> fields, use Option<PartialType>
-                    let inner_type_name = extract_option_inner_type(ty).unwrap();
-                    let partial_type = format_ident!("Partial{}", inner_type_name);
-                    quote! {
-                        #name: TomlValue<Option<#partial_type>>
-                    }
-                } else if is_vec_type(ty) {
-                    // For Vec<Nested> fields, use Vec<PartialType>
-                    let inner_type_name = extract_vec_inner_type(ty).unwrap();
-                    let partial_type = format_ident!("Partial{}", inner_type_name);
-                    quote! {
-                        #name: TomlValue<Vec<#partial_type>>
-                    }
-                } else {
-                    // For regular nested fields, use Partial{Type}
-                    let type_name = extract_type_name(ty).unwrap();
-                    let partial_type = format_ident!("Partial{}", type_name);
-                    quote! {
-                        #name: TomlValue<#partial_type>
-                    }
-                }
-            } else {
-                quote! {
-                    #name: TomlValue<#ty>
-                }
-            }
-        })
-        .collect();
-
-    let collect_errors_fields: Vec<_> = fields
-        .iter()
-        .map(|f| {
-            let name = &f.ident;
-            if is_nested_field(f) {
-                // For nested fields (including Option<Nested> and Vec<Nested>), recursively collect errors
-                if is_option_type(&f.ty) {
-                    // For Option<Nested>, value is Option<Option<PartialType>>
-                    quote! {
-                        if let Some(Some(ref partial)) = self.#name.value {
-                            partial.collect_errors(errors);
-                        }
-                    }
-                } else if is_vec_type(&f.ty) {
-                    // For Vec<Nested>, value is Option<Vec<PartialType>>
-                    quote! {
-                        if let Some(ref partials) = self.#name.value {
-                            for partial in partials.iter() {
-                                partial.collect_errors(errors);
-                            }
-                        }
-                    }
-                } else {
-                    quote! {
-                        if let Some(ref partial) = self.#name.value {
-                            partial.collect_errors(errors);
-                        }
-                    }
-                }
-            } else {
-                quote! {
-                    self.#name.register_error(errors)
-                }
-            }
-        })
-        .collect();
-
-    let can_concrete_fields: Vec<_> = fields
-        .iter()
-        .map(|f| {
-            let name = &f.ident;
-            if is_nested_field(f) {
-                // For nested fields, check if the partial can become concrete
-                // For Option<PartialType>, it's concrete if Some and inner can_concrete, or if None
-                if is_option_type(&f.ty) {
-                    quote! {
-                        self.#name.value.as_ref().map(|opt| {
-                            opt.as_ref().map(|p| p.can_concrete()).unwrap_or(true)
-                        }).unwrap_or(false)
-                    }
-                } else if is_vec_type(&f.ty) {
-                    // For Vec<Nested>, all items must be concrete
-                    quote! {
-                        self.#name.value.as_ref().map(|vec| {
-                            vec.iter().all(|p| p.can_concrete())
-                        }).unwrap_or(false)
-                    }
-                } else {
-                    quote! {
-                        self.#name.value.as_ref().map(|p| p.can_concrete()).unwrap_or(false)
-                    }
-                }
-            } else {
-                quote! {
-                    self.#name.has_value()
-                }
-            }
-        })
-        .collect();
-
-    let to_concrete_fields: Vec<_> = fields
-        .iter()
-        .map(|f| {
-            let name = &f.ident;
-            if is_nested_field(f) {
-                if is_option_type(&f.ty) {
-                    // For Option<Nested>, convert Option<Partial> to Option<Concrete>
-                    // self.#name.value is Option<Option<PartialNested>>
-                    // We need to flatten it and then convert
-                    quote! {
-                        #name: self.#name.value.flatten().and_then(|p| p.to_concrete())
-                    }
-                } else if is_vec_type(&f.ty) {
-                    // For Vec<Nested>, convert each partial in Vec<Partial> to Vec<Concrete>
-                    quote! {
-                        #name: self.#name.value.map(|vec| {
-                            vec.into_iter().filter_map(|p| p.to_concrete()).collect()
-                        }).unwrap()
-                    }
-                } else {
-                    // For regular nested fields, convert Partial to Concrete
-                    quote! {
-                        #name: self.#name.value.and_then(|p| p.to_concrete()).unwrap()
-                    }
-                }
-            } else {
-                quote! {
-                    #name: self.#name.unwrap()
-                }
-            }
-        })
-        .collect();
-
-    let from_toml_table_fields: Vec<_> = fields
-        .iter()
-        .map(|f| {
-            let name = &f.ident;
-            let name_str = name.as_ref().unwrap().to_string();
-            let aliases = extract_aliases(f);
-            
-            if is_nested_field(f) {
-                // For nested fields, we need to pass mode to as_nested
-                quote! {
-                    #name: helper.get_with_aliases(#name_str, vec![]).as_nested(&helper.errors, helper.match_mode)
-                }
-            } else if is_as_enum_field(f) {
-                // For enum fields, use aliases if present
-                if aliases.is_empty() {
-                    quote! {
-                        #name: helper.get(#name_str).as_enum()
-                    }
-                } else {
-                    quote! {
-                        #name: helper.get_with_aliases(#name_str, vec![]).as_enum()
-                    }
-                }
-            } else {
-                // For regular fields, use aliases if present
-                if aliases.is_empty() {
-                    quote! {
-                        #name: helper.get(#name_str)
-                    }
-                } else {
-                    quote! {
-                        #name: helper.get_with_aliases(#name_str, vec![#(#aliases),*])
-                    }
-                }
-            }
-        })
-        .collect();
-
-    // Conditionally generate VerifyFromToml impl
-    let generate_verify_impl = if generate_verify {
-        quote! {
-            impl #impl_generics VerifyFromToml<()> for #partial_name #ty_generics #where_clause {
-                fn verify(self, _helper: &mut TomlHelper<'_>, _partial: &()) -> Self {
-                    self
-                }
-            }
-        }
-    } else {
-        quote! {}
-    };
-
-    let expanded = quote! {
-        #cleaned_input
-
-        #[derive(Debug)]
-        struct #partial_name #generics #where_clause {
-            #(#partial_fields,)*
-        }
-
-        impl #impl_generics ToConcrete<#struct_name #ty_generics> for #partial_name #ty_generics #where_clause {
-            fn collect_errors(&self, errors: &Rc<RefCell<Vec<AnnotatedError>>>) {
-                #(#collect_errors_fields;)*
-            }
-
-            fn can_concrete(&self) -> bool {
-                #(#can_concrete_fields)&&*
-            }
-
-            fn to_concrete(self) -> Option<#struct_name #ty_generics> {
-                Some(#struct_name {
-                    #(#to_concrete_fields,)*
-                })
-            }
-        }
-
-        impl #impl_generics PartialEq for #partial_name #ty_generics #where_clause {
-            fn eq(&self, other: &Self) -> bool {
-                true
-            }
-        }
-
-        impl #impl_generics FromTomlTable<()> for #partial_name #ty_generics #where_clause {
-            fn from_toml_table(helper: &mut TomlHelper<'_>, _partial: &()) -> Self {
-                #partial_name {
-                    #(#from_toml_table_fields,)*
-                }
-            }
-        }
-
-        #generate_verify_impl
-    };
-
-    TokenStream::from(expanded)
+    Default::default() /* ~ changed by cargo-mutants ~ */
 }


*** /nix/store/826jircl576xphx7a459njgqfmcbd4x5-cargo-1.95.0-nightly-2026-01-21-x86_64-unknown-linux-gnu/bin/cargo test --no-run --verbose --package=toml-pretty-deser-macros@0.1.0
       Fresh unicode-ident v1.0.22
       Fresh proc-macro2 v1.0.106
       Fresh quote v1.0.44
       Fresh syn v2.0.114
       Dirty toml-pretty-deser-macros v0.1.0 (/tmp/nix-shell.fWA0aw/cargo-mutants-toml-pretty-deser-Ha55Kf.tmp/toml-pretty-deser-macros): the file `toml-pretty-deser-macros/src/lib.rs` has changed (1770035369.697698878s, 2s after last build at 1770035367.601788854s)
   Compiling toml-pretty-deser-macros v0.1.0 (/tmp/nix-shell.fWA0aw/cargo-mutants-toml-pretty-deser-Ha55Kf.tmp/toml-pretty-deser-macros)
     Running `rustc --crate-name toml_pretty_deser_macros --edition=2024 toml-pretty-deser-macros/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --crate-type proc-macro --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=81120a598c00f9fa -C extra-filename=-f792c9db6a0b2842 --out-dir /home/finkernagel/.cache/cargo/target/debug/deps -C incremental=/home/finkernagel/.cache/cargo/target/debug/incremental -L dependency=/home/finkernagel/.cache/cargo/target/debug/deps --extern proc_macro2=/home/finkernagel/.cache/cargo/target/debug/deps/libproc_macro2-3b81e34eea8b22ad.rlib --extern quote=/home/finkernagel/.cache/cargo/target/debug/deps/libquote-17bdff8842b26ed8.rlib --extern syn=/home/finkernagel/.cache/cargo/target/debug/deps/libsyn-2ef69c79628e106e.rlib --extern proc_macro -C link-arg=-fuse-ld=mold`
     Running `rustc --crate-name toml_pretty_deser_macros --edition=2024 toml-pretty-deser-macros/src/lib.rs --error-format=json --json=diagnostic-rendered-ansi,artifacts,future-incompat --emit=dep-info,link -C prefer-dynamic -C embed-bitcode=no -C debuginfo=2 --test --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' -C metadata=dff9d6b74d3ad59d -C extra-filename=-54b992e04b4c4902 --out-dir /home/finkernagel/.cache/cargo/target/debug/deps -C incremental=/home/finkernagel/.cache/cargo/target/debug/incremental -L dependency=/home/finkernagel/.cache/cargo/target/debug/deps --extern proc_macro2=/home/finkernagel/.cache/cargo/target/debug/deps/libproc_macro2-3b81e34eea8b22ad.rlib --extern quote=/home/finkernagel/.cache/cargo/target/debug/deps/libquote-17bdff8842b26ed8.rlib --extern syn=/home/finkernagel/.cache/cargo/target/debug/deps/libsyn-2ef69c79628e106e.rlib --extern proc_macro -C link-arg=-fuse-ld=mold`
warning: unused import: `format_ident`
 --> toml-pretty-deser-macros/src/lib.rs:2:13
  |
2 | use quote::{format_ident, quote};
  |             ^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Fields`
 --> toml-pretty-deser-macros/src/lib.rs:4:43
  |
4 |     parse_macro_input, Data, DeriveInput, Fields, GenericArgument, PathArguments, Type, TypePath,
  |                                           ^^^^^^

warning: unused variable: `attr`
   --> toml-pretty-deser-macros/src/lib.rs:185:21
    |
185 | pub fn make_partial(attr: TokenStream, item: TokenStream) -> TokenStream {
    |                     ^^^^ help: if this is intentional, prefix it with an underscore: `_attr`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `item`
   --> toml-pretty-deser-macros/src/lib.rs:185:40
    |
185 | pub fn make_partial(attr: TokenStream, item: TokenStream) -> TokenStream {
    |                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_item`

warning: function `is_nested_field` is never used
  --> toml-pretty-deser-macros/src/lib.rs:53:4
   |
53 | fn is_nested_field(field: &syn::Field) -> bool {
   |    ^^^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `is_as_enum_field` is never used
  --> toml-pretty-deser-macros/src/lib.rs:60:4
   |
60 | fn is_as_enum_field(field: &syn::Field) -> bool {
   |    ^^^^^^^^^^^^^^^^

warning: function `extract_aliases` is never used
  --> toml-pretty-deser-macros/src/lib.rs:68:4
   |
68 | fn extract_aliases(field: &syn::Field) -> Vec<String> {
   |    ^^^^^^^^^^^^^^^

warning: function `extract_type_name` is never used
   --> toml-pretty-deser-macros/src/lib.rs:103:4
    |
103 | fn extract_type_name(ty: &Type) -> Option<syn::Ident> {
    |    ^^^^^^^^^^^^^^^^^

warning: function `extract_option_inner_type` is never used
   --> toml-pretty-deser-macros/src/lib.rs:110:4
    |
110 | fn extract_option_inner_type(ty: &Type) -> Option<syn::Ident> {
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `is_option_type` is never used
   --> toml-pretty-deser-macros/src/lib.rs:134:4
    |
134 | fn is_option_type(ty: &Type) -> bool {
    |    ^^^^^^^^^^^^^^

warning: function `extract_vec_inner_type` is never used
   --> toml-pretty-deser-macros/src/lib.rs:147:4
    |
147 | fn extract_vec_inner_type(ty: &Type) -> Option<syn::Ident> {
    |    ^^^^^^^^^^^^^^^^^^^^^^

warning: function `is_vec_type` is never used
   --> toml-pretty-deser-macros/src/lib.rs:171:4
    |
171 | fn is_vec_type(ty: &Type) -> bool {
    |    ^^^^^^^^^^^

warning: `toml-pretty-deser-macros` (lib test) generated 12 warnings (12 duplicates)
warning: `toml-pretty-deser-macros` (lib) generated 12 warnings (run `cargo fix --lib -p toml-pretty-deser-macros` to apply 4 suggestions)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.12s
  Executable `/home/finkernagel/.cache/cargo/target/debug/deps/toml_pretty_deser_macros-54b992e04b4c4902`

*** result: Success

*** /nix/store/826jircl576xphx7a459njgqfmcbd4x5-cargo-1.95.0-nightly-2026-01-21-x86_64-unknown-linux-gnu/bin/cargo test --verbose --package=toml-pretty-deser-macros@0.1.0
       Fresh unicode-ident v1.0.22
       Fresh proc-macro2 v1.0.106
       Fresh quote v1.0.44
       Fresh syn v2.0.114
warning: unused import: `format_ident`
 --> toml-pretty-deser-macros/src/lib.rs:2:13
  |
2 | use quote::{format_ident, quote};
  |             ^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` (part of `#[warn(unused)]`) on by default

warning: unused import: `Fields`
 --> toml-pretty-deser-macros/src/lib.rs:4:43
  |
4 |     parse_macro_input, Data, DeriveInput, Fields, GenericArgument, PathArguments, Type, TypePath,
  |                                           ^^^^^^

warning: unused variable: `attr`
   --> toml-pretty-deser-macros/src/lib.rs:185:21
    |
185 | pub fn make_partial(attr: TokenStream, item: TokenStream) -> TokenStream {
    |                     ^^^^ help: if this is intentional, prefix it with an underscore: `_attr`
    |
    = note: `#[warn(unused_variables)]` (part of `#[warn(unused)]`) on by default

warning: unused variable: `item`
   --> toml-pretty-deser-macros/src/lib.rs:185:40
    |
185 | pub fn make_partial(attr: TokenStream, item: TokenStream) -> TokenStream {
    |                                        ^^^^ help: if this is intentional, prefix it with an underscore: `_item`

warning: function `is_nested_field` is never used
  --> toml-pretty-deser-macros/src/lib.rs:53:4
   |
53 | fn is_nested_field(field: &syn::Field) -> bool {
   |    ^^^^^^^^^^^^^^^
   |
   = note: `#[warn(dead_code)]` (part of `#[warn(unused)]`) on by default

warning: function `is_as_enum_field` is never used
  --> toml-pretty-deser-macros/src/lib.rs:60:4
   |
60 | fn is_as_enum_field(field: &syn::Field) -> bool {
   |    ^^^^^^^^^^^^^^^^

warning: function `extract_aliases` is never used
  --> toml-pretty-deser-macros/src/lib.rs:68:4
   |
68 | fn extract_aliases(field: &syn::Field) -> Vec<String> {
   |    ^^^^^^^^^^^^^^^

warning: function `extract_type_name` is never used
   --> toml-pretty-deser-macros/src/lib.rs:103:4
    |
103 | fn extract_type_name(ty: &Type) -> Option<syn::Ident> {
    |    ^^^^^^^^^^^^^^^^^

warning: function `extract_option_inner_type` is never used
   --> toml-pretty-deser-macros/src/lib.rs:110:4
    |
110 | fn extract_option_inner_type(ty: &Type) -> Option<syn::Ident> {
    |    ^^^^^^^^^^^^^^^^^^^^^^^^^

warning: function `is_option_type` is never used
   --> toml-pretty-deser-macros/src/lib.rs:134:4
    |
134 | fn is_option_type(ty: &Type) -> bool {
    |    ^^^^^^^^^^^^^^

warning: function `extract_vec_inner_type` is never used
   --> toml-pretty-deser-macros/src/lib.rs:147:4
    |
147 | fn extract_vec_inner_type(ty: &Type) -> Option<syn::Ident> {
    |    ^^^^^^^^^^^^^^^^^^^^^^

warning: function `is_vec_type` is never used
   --> toml-pretty-deser-macros/src/lib.rs:171:4
    |
171 | fn is_vec_type(ty: &Type) -> bool {
    |    ^^^^^^^^^^^

warning: `toml-pretty-deser-macros` (lib) generated 12 warnings (run `cargo fix --lib -p toml-pretty-deser-macros` to apply 4 suggestions)
       Fresh toml-pretty-deser-macros v0.1.0 (/tmp/nix-shell.fWA0aw/cargo-mutants-toml-pretty-deser-Ha55Kf.tmp/toml-pretty-deser-macros)
warning: `toml-pretty-deser-macros` (lib test) generated 12 warnings (12 duplicates)
    Finished `test` profile [unoptimized + debuginfo] target(s) in 0.01s
     Running `/home/finkernagel/.cache/cargo/target/debug/deps/toml_pretty_deser_macros-54b992e04b4c4902`

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s

   Doc-tests toml_pretty_deser_macros
     Running `rustdoc --edition=2024 --crate-type proc-macro --color auto --crate-name toml_pretty_deser_macros --test toml-pretty-deser-macros/src/lib.rs --test-run-directory /tmp/nix-shell.fWA0aw/cargo-mutants-toml-pretty-deser-Ha55Kf.tmp/toml-pretty-deser-macros --extern proc_macro2=/home/finkernagel/.cache/cargo/target/debug/deps/libproc_macro2-3b81e34eea8b22ad.rlib --extern quote=/home/finkernagel/.cache/cargo/target/debug/deps/libquote-17bdff8842b26ed8.rlib --extern syn=/home/finkernagel/.cache/cargo/target/debug/deps/libsyn-2ef69c79628e106e.rlib --extern toml_pretty_deser_macros=/home/finkernagel/.cache/cargo/target/debug/deps/libtoml_pretty_deser_macros-f792c9db6a0b2842.so --extern proc_macro -L dependency=/home/finkernagel/.cache/cargo/target/debug/deps -C embed-bitcode=no --check-cfg 'cfg(docsrs,test)' --check-cfg 'cfg(feature, values())' --error-format human`

running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s


*** result: Success
